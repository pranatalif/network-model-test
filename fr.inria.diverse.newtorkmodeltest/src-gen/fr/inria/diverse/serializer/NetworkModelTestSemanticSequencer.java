/*
 * generated by Xtext 2.16.0
 */
package fr.inria.diverse.serializer;

import com.google.inject.Inject;
import fr.inria.diverse.networkModelTest.Binding;
import fr.inria.diverse.networkModelTest.Config;
import fr.inria.diverse.networkModelTest.DataType;
import fr.inria.diverse.networkModelTest.Import;
import fr.inria.diverse.networkModelTest.LinkID;
import fr.inria.diverse.networkModelTest.Model;
import fr.inria.diverse.networkModelTest.NetworkModelTestPackage;
import fr.inria.diverse.networkModelTest.Node;
import fr.inria.diverse.networkModelTest.NodeA;
import fr.inria.diverse.networkModelTest.NodeB;
import fr.inria.diverse.networkModelTest.NodeType;
import fr.inria.diverse.networkModelTest.PackageDeclaration;
import fr.inria.diverse.services.NetworkModelTestGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class NetworkModelTestSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private NetworkModelTestGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == NetworkModelTestPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case NetworkModelTestPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case NetworkModelTestPackage.CONFIG:
				sequence_Config(context, (Config) semanticObject); 
				return; 
			case NetworkModelTestPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case NetworkModelTestPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case NetworkModelTestPackage.LINK_ID:
				sequence_LinkID(context, (LinkID) semanticObject); 
				return; 
			case NetworkModelTestPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case NetworkModelTestPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case NetworkModelTestPackage.NODE_A:
				sequence_NodeA(context, (NodeA) semanticObject); 
				return; 
			case NetworkModelTestPackage.NODE_B:
				sequence_NodeB(context, (NodeB) semanticObject); 
				return; 
			case NetworkModelTestPackage.NODE_TYPE:
				sequence_NodeType(context, (NodeType) semanticObject); 
				return; 
			case NetworkModelTestPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Binding returns Binding
	 *
	 * Constraint:
	 *     (nodeA=NodeA nodeB=NodeB linkID=STRING)
	 */
	protected void sequence_Binding(ISerializationContext context, Binding semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NetworkModelTestPackage.Literals.BINDING__NODE_A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NetworkModelTestPackage.Literals.BINDING__NODE_A));
			if (transientValues.isValueTransient(semanticObject, NetworkModelTestPackage.Literals.BINDING__NODE_B) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NetworkModelTestPackage.Literals.BINDING__NODE_B));
			if (transientValues.isValueTransient(semanticObject, NetworkModelTestPackage.Literals.BINDING__LINK_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NetworkModelTestPackage.Literals.BINDING__LINK_ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindingAccess().getNodeANodeAParserRuleCall_1_0(), semanticObject.getNodeA());
		feeder.accept(grammarAccess.getBindingAccess().getNodeBNodeBParserRuleCall_3_0(), semanticObject.getNodeB());
		feeder.accept(grammarAccess.getBindingAccess().getLinkIDSTRINGTerminalRuleCall_6_0(), semanticObject.getLinkID());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeElement returns Config
	 *     Type returns Config
	 *     Config returns Config
	 *
	 * Constraint:
	 *     (name=ID superType=[Config|QualifiedName]? node+=Node+ binding+=Binding+)
	 */
	protected void sequence_Config(ISerializationContext context, Config semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeElement returns DataType
	 *     Type returns DataType
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NetworkModelTestPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NetworkModelTestPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataTypeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeElement returns Import
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNameSpace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NetworkModelTestPackage.Literals.IMPORT__IMPORTED_NAME_SPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NetworkModelTestPackage.Literals.IMPORT__IMPORTED_NAME_SPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNameSpaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNameSpace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LinkID returns LinkID
	 *
	 * Constraint:
	 *     linkID=STRING
	 */
	protected void sequence_LinkID(ISerializationContext context, LinkID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NetworkModelTestPackage.Literals.LINK_ID__LINK_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NetworkModelTestPackage.Literals.LINK_ID__LINK_ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLinkIDAccess().getLinkIDSTRINGTerminalRuleCall_0(), semanticObject.getLinkID());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     elements+=NodeElement+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeA returns NodeA
	 *
	 * Constraint:
	 *     (name=ID eth=ID)
	 */
	protected void sequence_NodeA(ISerializationContext context, NodeA semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NetworkModelTestPackage.Literals.NODE_A__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NetworkModelTestPackage.Literals.NODE_A__NAME));
			if (transientValues.isValueTransient(semanticObject, NetworkModelTestPackage.Literals.NODE_A__ETH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NetworkModelTestPackage.Literals.NODE_A__ETH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeAAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNodeAAccess().getEthIDTerminalRuleCall_2_0(), semanticObject.getEth());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeB returns NodeB
	 *
	 * Constraint:
	 *     (name=ID eth=ID)
	 */
	protected void sequence_NodeB(ISerializationContext context, NodeB semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, NetworkModelTestPackage.Literals.NODE_B__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NetworkModelTestPackage.Literals.NODE_B__NAME));
			if (transientValues.isValueTransient(semanticObject, NetworkModelTestPackage.Literals.NODE_B__ETH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, NetworkModelTestPackage.Literals.NODE_B__ETH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeBAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNodeBAccess().getEthIDTerminalRuleCall_2_0(), semanticObject.getEth());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeType returns NodeType
	 *
	 * Constraint:
	 *     (
	 *         nodetype='Docker' | 
	 *         nodetype='OVS' | 
	 *         nodetype='EthSwitch' | 
	 *         nodetype='Firefox' | 
	 *         nodetype='UbuntuDesktop' | 
	 *         nodetype='NAT' | 
	 *         nodetype='Cloud'
	 *     )
	 */
	protected void sequence_NodeType(ISerializationContext context, NodeType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (
	 *         nodetype=NodeType 
	 *         name=ID 
	 *         image=STRING? 
	 *         nodeName=STRING 
	 *         nodeID=STRING 
	 *         nodeIP=STRING?
	 *     )
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeElement returns PackageDeclaration
	 *     PackageDeclaration returns PackageDeclaration
	 *
	 * Constraint:
	 *     (name=QualifiedName elements+=NodeElement*)
	 */
	protected void sequence_PackageDeclaration(ISerializationContext context, PackageDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
